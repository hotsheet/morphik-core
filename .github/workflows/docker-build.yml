name: Build Docker Image

on:
  pull_request
  
permissions:
  contents: read

jobs:
  docker-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Copy Docker config
        run: |
          echo "Using centralized Docker config from .github/config/morphik.toml"
          cp .github/config/morphik.toml morphik.toml
          echo "Config file updated:"
          head -10 morphik.toml

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          sudo docker builder prune -a --force
          df -h

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/morphik-core
          tags: |
            type=ref,event=pr
            type=sha,prefix=pr-{{branch}}-
            
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./dockerfile
          push: false
          load: true
          tags: |
            ${{ steps.meta.outputs.tags }}
            morphik-core:test
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          # Remove cache-to for PR builds to save disk space 
          
      - name: Test Docker container
        run: |
          # Use the local test tag instead of the registry tag
          IMAGE_TAG="morphik-core:test"
          echo "Testing image: $IMAGE_TAG"

          # Create a custom network for the containers to communicate
          NETWORK_NAME="morphik-test-network"
          docker network create $NETWORK_NAME

          # Start pgvector PostgreSQL container
          echo "Starting pgvector PostgreSQL container..."
          DB_CONTAINER_ID=$(docker run -d \
            --name pgvector-test \
            --network $NETWORK_NAME \
            -e POSTGRES_USER=morphik \
            -e POSTGRES_PASSWORD=morphik \
            -e POSTGRES_DB=morphik \
            -p 5432:5432 \
            ankane/pgvector:latest)

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker exec $DB_CONTAINER_ID pg_isready -U morphik -d morphik; then
              echo "PostgreSQL is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "PostgreSQL failed to start"
              docker logs $DB_CONTAINER_ID
              exit 1
            fi
            sleep 1
          done

          # Enable pgvector extension
          echo "Enabling pgvector extension..."
          docker exec $DB_CONTAINER_ID psql -U morphik -d morphik -c 'CREATE EXTENSION IF NOT EXISTS vector;'

          # Start Redis container (NOTE: must be named "redis")
          echo "Starting Redis container..."
          REDIS_CONTAINER_ID=$(docker run -d \
            --name redis \
            --network $NETWORK_NAME \
            -p 6379:6379 \
            -v redis_data:/data \
            redis:7-alpine \
            redis-server --appendonly yes)

          # Wait for Redis to be ready
          echo "Waiting for Redis to be ready..."
          for i in {1..30}; do
            if docker exec $REDIS_CONTAINER_ID redis-cli ping | grep -q PONG; then
              echo "Redis is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Redis failed to start"
              docker logs $REDIS_CONTAINER_ID
              exit 1
            fi
            sleep 1
          done

          # Start application container
          echo "Starting application container..."
          CONTAINER_ID=$(docker run -d \
            --network $NETWORK_NAME \
            -p 8000:8000 \
            -e POSTGRES_URI="postgresql+asyncpg://morphik:morphik@pgvector-test:5432/morphik" \
            -v "$(pwd)/morphik.toml:/app/morphik.toml" \
            "$IMAGE_TAG")

          echo "Started container: $CONTAINER_ID"

          # Wait for server to be ready
          timeout=300  # long timeout required to load checkpoint shards
          interval=2
          elapsed=0

          echo "Waiting for server to be ready..."
          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost:8000/ping > /dev/null 2>&1; then
              echo "✅ Server is responding to /ping endpoint"
              break
            fi

            echo "⏳ Waiting for server... (${elapsed}s/${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done

          # Check if we timed out
          if [ $elapsed -ge $timeout ]; then
            echo "❌ Server failed to respond within ${timeout} seconds"
            echo "Container logs:"
            docker logs "$CONTAINER_ID"
            echo "Database logs:"
            docker logs "$DB_CONTAINER_ID"
            echo "Redis logs:"
            docker logs "$REDIS_CONTAINER_ID"
            docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
            docker rm -f "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
            docker network rm "$NETWORK_NAME" || true
            docker volume rm redis_data 2>/dev/null || true
            exit 1
          fi

          # Verify the response is actually 200
          response_code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/ping)
          if [ "$response_code" -ne 200 ]; then
            echo "❌ Unexpected response code: $response_code"
            echo "Container logs:"
            docker logs "$CONTAINER_ID"
            echo "Database logs:"
            docker logs "$DB_CONTAINER_ID"
            echo "Redis logs:"
            docker logs "$REDIS_CONTAINER_ID"
            docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
            docker rm -f "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
            docker network rm "$NETWORK_NAME" || true
            docker volume rm redis_data 2>/dev/null || true
            exit 1
          fi

          echo "✅ Tests passed!"
          docker stop "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
          docker rm -f "$CONTAINER_ID" "$DB_CONTAINER_ID" "$REDIS_CONTAINER_ID" || true
          docker network rm "$NETWORK_NAME" || true
          docker volume rm redis_data 2>/dev/null || true
          echo "✅ Test completed successfully"